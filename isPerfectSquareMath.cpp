/*
二分法：
   对于一个给定的正整数n，可以使用二分法在1到n之间查找是否存在一个整数x使得x的平方等于n。
        1.具体来说，可以从区间的中间位置开始，如果中间位置的平方等于n，则返回true；
        2.否则如果中间位置的平方小于n，则在右半区间继续查找；否则在左半区间继续查找。
        3.重复上述步骤直到区间缩小为1或者找到一个平方等于n的整数。时间复杂度为O(log n)。
数学方法：
    对于一个给定的正整数n，如果n是完全平方数，那么它可以表示为一个奇数个连续自然数的和。
    例如，9可以表示为1+3+5，16可以表示为1+3+5+7，以此类推。
    因此，可以从1开始枚举连续自然数的和，直到找到一个和等于n为止。
    如果找到了这样的和，则n是完全平方数；否则不是。时间复杂度最坏情况下为O(sqrt(n))
 */
#include <iostream>
#include <math.h>
#include <vector>
using namespace std;
//方法一
bool isPerfectSquareMath1(int num){
    int left = 1;
    int right = num;
    while (left <= right)
    {   
        int mid = left + (right-left)/2;
        int square = mid * mid;
        if(square == num){
            return true;
        }
        else if(square < num){
            left = mid+1;
        }
        else{
            right = mid-1;
        }
    }
    return false;
}

//方法二
bool isPerfectSquareMath2(int num){
    int sum = 1;
    while (num > 0)
    {
        num-=sum;
        sum +=2;
    }
    return num == 0;
}


int main(){
    vector<int>num={1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484,529,576,625,676,729,784,841,900,961,1024,1089,1156,1225,1296,1369,1444,1521,1600,1681,1764,1849,1936,2025,2116,2209,2304,2401,2500,2601,2704,2809,2916,3025,3136,3249,3364,3481,3600,3721,3844,3969,4096,4225,4356,4489,4624,4761,4900,5041,5184,5329,5476,5625,5776,5929,6084,6241,6400,6561,6724,6889,7056,7225,7396,7569,7744,7921,8100,8281,8464,8649,8836,9025,9216,9409,9604,9801,10000};
    for(int i=1; i<=pow(10,4);i++){
        if(isPerfectSquareMath2(i)){
            cout<< i <<",";
        }
    }
    return 0;
}
